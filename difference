diff --cc plugin.yml
index 2129efc,7b9475c..0000000
--- a/plugin.yml
+++ b/plugin.yml
@@@ -2,5 -2,9 +2,14 @@@ name: TweakCar
  main: com.tweakcart.TweakCart
  authors: [Meaglin, The-Sec, windwarrior, Edoxile]
  website: https://github.com/Edoxile/TweakCart
++<<<<<<< HEAD
 +version: 0.2.4
 +
++=======
+ version: 0.3.0
+ commands:
+     cartdebug:
+         description: Show TweakCart debug info
+         usage: /cartdebug
+         aliases: [cd]
++>>>>>>> dev
diff --cc src/com/tweakcart/listeners/TweakCartVehicleListener.java
index f1116af,6629d6f..0000000
--- a/src/com/tweakcart/listeners/TweakCartVehicleListener.java
+++ b/src/com/tweakcart/listeners/TweakCartVehicleListener.java
@@@ -110,32 -135,98 +135,125 @@@ public class TweakCartVehicleListener e
          }
      }
  
++<<<<<<< HEAD
 +    private void parseSign(Sign sign, Minecart cart, Direction direction) {
 +        HashMap<SignParser.Action, IntMap> dataMap = SignParser.parseSign(sign, direction);
 +        if (SignParser.checkStorageCart(cart)) {
 +            StorageMinecart storageCart = (StorageMinecart) cart;
 +            List<Chest> chests;
 +            for (Map.Entry<SignParser.Action, IntMap> entry : dataMap.entrySet()) {
 +                if (entry.getValue() == null)
 +                    continue;
 +                switch (entry.getKey()) {
 +                    case COLLECT:
 +                        //Collect items (from cart to chest)
 +                        chests = ChestUtil.getChestsAroundBlock(sign.getBlock(), 1);
 +                        IntMap temp = entry.getValue();
 +                        for (Chest c : chests) {
 +                            temp = ChestUtil.moveItems(storageCart.getInventory(), c.getInventory(), temp);
 +                        }
 +                        break;
 +                    case DEPOSIT:
 +                        //Deposit items (from chest to cart)
 +                        chests = ChestUtil.getChestsAroundBlock(sign.getBlock(), 1);
 +                        for (Chest c : chests) {
 +                            ChestUtil.moveItems(c.getInventory(), storageCart.getInventory(), entry.getValue());
 +                        }
 +                        break;
++=======
+ 
+     private void parseItemSign(Sign sign, StorageMinecart cart, Direction direction) {
+         List<IntMap> intmaps;
+         List<Chest> chests;
+         SignLocation loc = new SignLocation(sign.getX(), sign.getY(), sign.getZ());
+         List<IntMap> temp = softmap.get(loc);
+         if(temp != null && containsDirection(temp, direction)){
+             intmaps = stripDirection(temp, direction);
+             softMapHits++;
+         }
+         else{
+             intmaps = SignParser.parseItemSign(sign, direction);
+             if(softmap.get(loc) != null){
+                 List<IntMap> prevresult = softmap.get(loc);
+                 for(int i = 0; i < prevresult.size(); i++){
+                     if(!intmaps.contains(prevresult.get(i))){
+                         intmaps.add(prevresult.get(i));
+                     }
++>>>>>>> dev
                  }
+                 softmap.put(loc, intmaps);
+                 softMapPartialMisses++;
              }
+             else{
+                 softmap.put(loc, intmaps);
+                 softMapMisses++;
+             }
+ 
          }
+         for (IntMap map: intmaps) {
+             if (map == null)
+                 continue;
+             switch (map.getAction()) {
+                 case COLLECT:
+                     //Collect items (from cart to chest)
+                     chests = ChestUtil.getChestsAroundBlock(sign.getBlock(), 1);
+                     for (Chest c : chests) {
+                         ChestUtil.moveItems(cart.getInventory(), c.getInventory(), map, true);
+                     }
+                     break;
+                 case DEPOSIT:
+                     //Deposit items (from chest to cart)
+                     chests = ChestUtil.getChestsAroundBlock(sign.getBlock(), 1);
+                     for (Chest c : chests) {
+                         ChestUtil.moveItems(c.getInventory(), cart.getInventory(), map, false);
+                     }
+                     break;
+             }
+         }
+     }
+ 
+     private List<IntMap> stripDirection(List<IntMap> temp, Direction dir) {
+        List<IntMap> result = new ArrayList<IntMap>();
+        for(int i = 0; i < temp.size(); i++){
+            if(temp.get(i).getDirection() == dir || temp.get(i).getDirection() == Direction.SELF){
+                result.add(temp.get(i));
+            }
+        }
+        
+        return result;
+     }
+ 
+     private boolean containsDirection(List<IntMap> list, Direction dir) {
+         for(Iterator<IntMap> it = list.iterator(); it.hasNext();){
+             Direction dir2 = it.next().getDirection();
+             if(dir2 == dir){
+                 return true;
+             }
+         }
+         return false;
+          
+     }
+     
+     public int getSoftMapHits(){
+         return softMapHits;
+     }
+     
+     public int getSoftMapMisses(){
+         return softMapMisses;
+     }
+     
+     public int getPartialMisses(){
+         return softMapPartialMisses;
+     }
+     
+     /**
+      * TODO: write this function.
+      */
+     public void parseRouteSign(Sign sign, Minecart cart, Direction direction) {
+         //fill this
+     }
+ 
+     public void removeEntry(SignLocation loc) {
+         softmap.remove(loc);      
      }
  }
diff --cc src/com/tweakcart/model/IntMap.java
index f4fb307,60d433f..0000000
--- a/src/com/tweakcart/model/IntMap.java
+++ b/src/com/tweakcart/model/IntMap.java
@@@ -3,23 -5,26 +5,36 @@@ import org.bukkit.ChatColor
  import org.bukkit.Material;
  import org.bukkit.material.MaterialData;
  
+ import com.tweakcart.model.SignParser.Action;
+ 
  /**
 - * Created by IntelliJ IDEA.
 + * Created by Eclipse.
   *
   * @author TheSec, Edoxile
   */
  public class IntMap {
 -    private static final int materialSize = Material.values().length - 1;
 +    public static final int materialSize = Material.values().length;
 +    public static final int mapSize = materialSize + 57;
      private int[] mapData;
+     private Direction dir;
+     private Action act;
  
      public IntMap() {
++<<<<<<< HEAD
 +        mapData = new int[mapSize];
 +    }
 +
 +    private IntMap(int[] data) {
 +        if (data.length != (mapSize)) {
 +            mapData = new int[mapSize];
++=======
+         mapData = new int[materialSize + 50];
+     }
+ 
+     private IntMap(int[] data) {
+         if (data.length != (materialSize + 50)) {
+             mapData = new int[materialSize + 50];
++>>>>>>> dev
          } else {
              mapData = data;
          }
@@@ -194,14 -183,15 +209,24 @@@
      }
  
      private boolean setDataRange(int id, byte start, byte end, int amount) {
++<<<<<<< HEAD
 +        if (!hasDataValue(id)){
++=======
+         Bukkit.getServer().broadcastMessage("" + ChatColor.RED + materialSize);
+         if (!hasDataValue(id))
++>>>>>>> dev
              return false;
 -
 +        }
          for (byte data = start; data <= end; data++) {
              int key = getIntIndex(id, data);
++<<<<<<< HEAD
 +            if (key == -1){
++=======
+             Bukkit.getServer().broadcastMessage(id + " " + data + " " + key);
+             if (key == -1)
++>>>>>>> dev
                  break;
 +            }
              mapData[key] = amount;
          }
          return true;
@@@ -211,11 -201,16 +236,22 @@@
      public boolean equals(Object other) {
          if (other instanceof IntMap) {
              IntMap otherMap = (IntMap) other;
++<<<<<<< HEAD
 +            for (int index = 0; index <= mapData.length; index++) {
 +                if (mapData[index] != otherMap.mapData[index])
 +                    return false;
++=======
+             if(otherMap.getDirection() == this.getDirection()){
+                 for (int index = 0; index < mapData.length; index++) {
+                     if (mapData[index] != otherMap.mapData[index])
+                         return false;
+                 }
+                 return true;
+             }
+             else{
+                 return false;
++>>>>>>> dev
              }
-             return true;
          } else {
              return false;
          }
diff --cc src/com/tweakcart/model/SignParser.java
index 694e1b2,76dd966..0000000
--- a/src/com/tweakcart/model/SignParser.java
+++ b/src/com/tweakcart/model/SignParser.java
@@@ -51,16 -47,11 +47,24 @@@ public class SignParser 
                      case 's':
                      case 'w':
                      case 'e':
++<<<<<<< HEAD
 +                    case 'N':
 +                    case 'S':
 +                    case 'W':
 +                    case 'E':
 +                        if (line.length() > 2) {
 +                            if (line.charAt(2) == 'a' && line.equals(Character.toString(line.charAt(0)) + "+all items")) {
 +                                return Action.ALL;
 +                            } else {
 +                                return Action.ITEM;
 +                            }
++=======
+                         if (checkDirection(firstChar, direction)) {
+                             if (line.charAt(2) == 'a' && line.contains("all items")) {
+                                 return Action.ALL;
+                             }
+                             return Action.ITEM;
++>>>>>>> dev
                          } else {
                              return Action.NULL;
                          }
@@@ -96,38 -87,41 +100,73 @@@
      public static IntMap buildIntMap(String line) {
          IntMap map = new IntMap();
          boolean isNegate = false;
+         if (line.length() >= 2 && line.charAt(1) == '+') {
+             //TODO Eigenlijk is dit niet net, gezien we deze opvraag net ook al gedaan hebben
+             map.setDirection(getDirection(line.charAt(0)));
+             line = line.substring(2);
+         }
+         else{
+             map.setDirection(Direction.SELF); 
+         }
+         if (line.charAt(0) == '!') {
+             isNegate = true;
+             line = line.substring(1);
+         }
  
++<<<<<<< HEAD
 +        if (line.length() >= 2 && line.charAt(1) == '+') {
 +            line = line.substring(2);
 +        }
 +        if (line.charAt(0) == '!') {
 +            isNegate = true;
 +            line = line.substring(1);
 +        }
 +
++=======
++>>>>>>> dev
          String[] commands = line.split(":");
  
          for (String command : commands) {
              int value = 0;
  
++<<<<<<< HEAD
 +            String[] splitline = command.split("@");
 +
 +            if (splitline.length == 2) {
 +                try {
 +                    value = Integer.parseInt(splitline[1]);
 +                    value = (value < 1 ? Integer.MAX_VALUE : value);
 +                    command = splitline[0];
 +                } catch (NumberFormatException e) {
 +                    return null;
 +                }
 +            } else if (splitline.length != 1) {
 +                return null;
 +            }
 +
 +            splitline = command.split("-");
 +            if (splitline.length == 2) {
 +                int[] startPair = checkIDData(splitline[0]);
 +                int[] endPair = checkIDData(splitline[1]);
++=======
+             String[] splitLine = command.split("@");
+ 
+             if (splitLine.length == 2) {
+                 try {
+                     value = Integer.parseInt(splitLine[1]);
+                     value = (value < 1 ? Integer.MAX_VALUE : value);
+                     command = splitLine[0];
+                 } catch (NumberFormatException e) {
+                     return null;
+                 }
+             } else if (splitLine.length != 1) {
+                 return null;
+             }
+             splitLine = command.split("-");
+             if (splitLine.length == 2) {
+                 int[] startPair = checkIdData(splitLine[0]);
+                 int[] endPair = checkIdData(splitLine[1]);
++>>>>>>> dev
                  if (startPair != null && endPair != null) {
                      if (value == 0) {
                          if (isNegate) {
@@@ -140,8 -134,8 +179,13 @@@
                  } else {
                      return null;
                  }
++<<<<<<< HEAD
 +            } else if (splitline.length == 1) {
 +                int[] pair = checkIDData(splitline[0]);
++=======
+             } else if (splitLine.length == 1) {
+                 int[] pair = checkIdData(splitLine[0]);
++>>>>>>> dev
                  if (pair != null) {
                      if (value == 0) {
                          if (isNegate) {
@@@ -149,20 -143,14 +193,27 @@@
                          } else {
                              value = Integer.MAX_VALUE;
                          }
++<<<<<<< HEAD
 +
 +                    }
 +                    map.setInt(pair[0], (byte) (pair[1] & 0xff), value);
 +                } else {
 +                    //Ah er is dus iets mis gegaan bij het parsen
 +                    return null;
 +                }
 +
 +            } else {
 +                //De gebruiker heeft meerdere '-' tekens aangegeven, en dat kan niet
++=======
+                     }
+                     map.setInt(pair[0], (byte) (pair[1] & 0xff), value);
+                 } else {
+                     return null;
+                 }
+             } else {
++>>>>>>> dev
                  return null;
              }
- 
- 
          }
  
          return map;
@@@ -191,115 -177,186 +240,236 @@@
  
      }
  
-     private static boolean checkDirection(String line, Direction d) {
-         if (line.length() >= 2 && line.charAt(1) == '+') {
-             char c = line.charAt(0);
-             switch (c) {
-                 case 'n':
-                     if (d != Direction.NORTH) {
-                         return false;
-                     }
-                     break;
-                 case 's':
-                     if (d != Direction.SOUTH) {
-                         return false;
+     private static boolean checkDirection(char c, Direction d) {
+         return (getDirection(c) == d || getDirection(c) == Direction.SELF); //Yay, 10 keer zo kort ofzo :)
+     }
+ 
+     /**
+      * TODO: implement this function. It automatically teleports the cart to the correct location and in the correct direction (this is why cart is an argument).
+      */
+     public static boolean parseRouteSign(Sign sign, Direction direction, Minecart cart) {
+         //BASIC syntax: [Direction from <N,S,E,W>];[Type of cart <S,M,P>],[Full/Empty <F,E>];[Direction to go <N,S,E,W>]
+         //Example: S,F;N: makes storagecarts that are full go north :)        
+         String[] lines = sign.getLines();
+         
+         for(int i = 0; i < lines.length; i++){
+             String line = lines[i];
+             Minecart type;
+             
+             String[] temp = line.split(":");
+             for(String partline: temp){
+                 String[] directionalparts = partline.split(";");
+                 if(directionalparts.length == 3){
+                     //deel 1 is een direction
+                     Direction from = getDirection(directionalparts[0].toLowerCase().charAt(0));
+                     if(from != direction && direction != Direction.SELF){
+                         continue;
                      }
-                     break;
-                 case 'e':
-                     if (d != Direction.EAST) {
-                         return false;
+                     Direction to = getDirection(directionalparts[2].toLowerCase().charAt(0));
+                     String[] cartTypeFullness = directionalparts[1].split(";");
+                     if(cartTypeFullness.length == 2 && checkCartType(cartTypeFullness[0], cart)){
+                         boolean fullcart = getFull(cartTypeFullness[1].toLowerCase().charAt(0));
+                         if(cart instanceof StorageMinecart){
+                             StorageMinecart storecart = (StorageMinecart) cart;
+                             if(storecart.isEmpty() == !fullcart){
+                                 //oke moven dan maar ;)
+                             }
+                         }else if(cart instanceof PoweredMinecart){
+                             PoweredMinecart powcart = (PoweredMinecart) cart;
+                             if(powcart.isEmpty() == !fullcart){
+                                 //ook maar moven
+                             }
+                         }else{
+                             if(cart.isEmpty() == !fullcart){
+                                 //whatever :)
+                             }
+                         }
                      }
-                     break;
-                 case 'w':
-                     if (d != Direction.WEST) {
-                         return false;
+                     else{
+                         continue;
                      }
-                     break;
+                     
+                 }else if(directionalparts.length == 2){
+                     Direction to = getDirection(directionalparts[1].toLowerCase().charAt(0));
+                     String[] cartTypeFullness = directionalparts[1].split(";");
+                 }else{
+                     //User fail
+                 }
+                 
              }
- 
          }
-         return true;
+         
+         return false;
+     }
+     
+     /**
+      * Langste methode EVURR!
+      * @param c
+      * @return
+      */
+     private static boolean getFull(char c) {        
+         return c == 'f';
+     }
  
+     private static boolean checkCartType(String type, Minecart cart) {
+         char carttypechar = type.toLowerCase().charAt(0);
+         switch(carttypechar){
+         case 's':
+             if(cart instanceof StorageMinecart) return true;
+             break;
+         case 'p':
+             if(cart instanceof PoweredMinecart) return true;
+             break;
+         case 'm':
+             if(cart instanceof Minecart) return true;
+             break;        
+         }
+         return false;
      }
  
++<<<<<<< HEAD
 +    public static HashMap<Action, IntMap> parseSign(Sign sign, Direction direction) {
++=======
+     private static Direction getDirection(char c){
+         switch(c){
+         case 'n':
+             return Direction.NORTH;
+         case 's':
+             return Direction.SOUTH;
+         case 'e':
+             return Direction.EAST;
+         case 'w':
+             return Direction.WEST;
+         default:
+             return Direction.SELF;
  
+         }
+     }
+     
++>>>>>>> dev
+ 
+     public static List<IntMap> parseItemSign(Sign sign, Direction direction) {
          Action oldAction = Action.NULL;
  
-         HashMap<Action, IntMap> returnData = new HashMap<Action, IntMap>();
+         List<IntMap> returndata = new ArrayList<IntMap>();
          IntMap map;
- 
          for (String line : sign.getLines()) {
              line = removeBrackets(line);
-             Action newAction = SignParser.parseAction(line);
+             line = line.toLowerCase();
+             Action newAction = SignParser.parseAction(line, direction);
              if (newAction == Action.NULL) {
                  continue;
              } else if (newAction != Action.ITEM && newAction != Action.ALL) {
                  oldAction = newAction;
                  continue;
              } else if (oldAction != Action.NULL) {
++<<<<<<< HEAD
 +                if (checkDirection(line, direction)) {
 +                    switch (oldAction) {
 +                        case DEPOSIT:
 +                        case COLLECT:
 +                            switch (newAction) {
 +                                case ALL:
 +                                    if (returnData.containsKey(oldAction)) {
 +                                        map = returnData.get(oldAction);
 +                                        map.fillAll();
 +                                        returnData.put(oldAction, map);
 +                                    } else {
 +                                        map = new IntMap();
 +                                        map.fillAll();
 +                                        returnData.put(oldAction, map);
 +                                    }
 +                                    break;
 +                                case ITEM:
 +                                    IntMap parsed = buildIntMap(line);
 +
 +                                    if (parsed != null) {
 +                                        // Mooi het is gelukt! Maps combinen dan maar!
 +                                        if (returnData.containsKey(oldAction)) {
 +                                            map = returnData.get(oldAction);
 +                                            map.combine(parsed);
 +                                            returnData.put(oldAction, map);
 +                                        } else {
 +                                            if (parsed != null)
 +                                                returnData.put(oldAction, parsed);
 +                                        }
 +                                    }
 +                                    break;
 +                                default:
 +                                    //WTH?
 +                                    break;
 +                            }
 +                            break;
 +                        //case ELEVATE?
 +                        default:
 +                            //Weird stuff is going on!
 +                            break;
 +                    }
 +                } else {
 +                    continue;
++=======
+                 switch (oldAction) {
+                     case DEPOSIT:
+                     case COLLECT:
+                         switch (newAction) {
+                             case ALL:
+                                 IntMap tempmap = null;
+                                 int maplocation = -1;
+                                 boolean running = true;
+                                 for(int i = 0; i < returndata.size() && running; i++){
+                                     IntMap nextmap = returndata.get(i);
+                                     if(nextmap.getAction().equals(oldAction)){
+                                         tempmap = nextmap;
+                                         maplocation = i;
+                                         running = false;
+                                     }
+                                 }
+                                 if (tempmap != null) {
+                                     map = tempmap;
+                                     map.fillAll();
+                                     map.setAction(oldAction);
+                                     returndata.set(maplocation, map);
+                                 } else {
+                                     map = new IntMap();
+                                     map.fillAll();
+                                     map.setAction(oldAction);
+                                     returndata.add(map);
+                                 }
+                                 break;
+                             case ITEM:
+                                 IntMap parsed = buildIntMap(line);
+                                 if (parsed != null) {
+                                     //OEEEH, daar gebruikte ik control v, dat moet toch netter kunen :)
+                                     IntMap tempmap2 = null;
+                                     int maplocation2 = -1;
+                                     boolean running2 = true;
+                                     for(int i = 0; i < returndata.size() && running2; i++){
+                                         IntMap nextmap = returndata.get(i);
+                                         if(nextmap.getAction().equals(oldAction)){
+                                             tempmap2 = nextmap;
+                                             maplocation2 = i;
+                                             running2 = false;
+                                         }
+                                     }
+                                     
+                                     
+                                     if (tempmap2 != null) {
+                                         map = tempmap2;
+                                         map.combine(parsed);
+                                         map.setAction(oldAction);
+                                         returndata.set(maplocation2, map);
+                                     } else {
+                                         parsed.setAction(oldAction);
+                                         returndata.add(parsed);
+                                     }
+                                 }
+                                 break;
+                         }
+                         break;
++>>>>>>> dev
                  }
-             } else {
-                 //Oldaction == Null and newAction is Item, so don't do anything.
-                 continue;
              }
          }
- 
-         //Yay, we hebben een IntMap
-         //For simplicity sake, gaan we er vanuit dat het of collect of deposit is, oke :)
- 
-         return returnData;
-     }
- 
- 
-     public static boolean checkStorageCart(Minecart cart) {
-         return (cart instanceof StorageMinecart);
-     }
- 
-     public static boolean checkCart(Minecart cart) {
-         return !((cart instanceof StorageMinecart) || (cart instanceof PoweredMinecart));
+         return returndata;
      }
  }
diff --cc src/com/tweakcart/util/ChestUtil.java
index 21abc13,26c5edf..0000000
--- a/src/com/tweakcart/util/ChestUtil.java
+++ b/src/com/tweakcart/util/ChestUtil.java
@@@ -33,7 -32,6 +33,10 @@@ public class ChestUtil 
                          from[i1].setAmount((to[i2].getAmount() + from[i1].getAmount()) - 64);
                          to[i2].setAmount(64);
                          i1--;
++<<<<<<< HEAD
 +
++=======
++>>>>>>> dev
                      } else {
                          to[i2].setAmount(to[i2].getAmount() + from[i1].getAmount());
                          from[i1] = null;
@@@ -51,146 -49,56 +54,194 @@@
          ItemStack[] stacks = {from};
          return putItems(stacks, containerBlock);
      }
++<<<<<<< HEAD
 +    
 +    public static IntMap moveItems(Inventory iFrom, Inventory iTo, IntMap settings) {
 +        ItemStack[] from = iFrom.getContents();
 +        ItemStack[] to = iTo.getContents();
 +        main:for(int index = 0; index < from.length; index++ ) { 
 +            if(from[index] == null) continue;
 +            byte data = from[index].getDurability() > Byte.MAX_VALUE ? 0 : IntMap.isAllowedMaterial(from[index].getTypeId(), (byte) from[index].getDurability()) ? (byte) from[index].getDurability() : 0;
 +
 +            ItemStack itemFrom = from[index];
 +            int typeid = itemFrom.getTypeId();
 +            if(settings.getInt(typeid, data) <= 0) continue;
 +            //System.out.println("[0]f: (" + typeid + ")" + itemFrom.getAmount() + " d:" + data);
 +            /*
 +             * First we try to append an existing stack.
 +             */
 +            for(int indexto = 0; indexto < to.length; indexto++ ) {
 +                if(itemFrom.getAmount() <= 0) break;
 +                ItemStack itemTo = to[indexto];                
 +                if(itemTo == null) continue;
 +                if(itemTo.getAmount() == 0) {
 +                	to[indexto] = null;
 +                	continue;
 +                }
 +                if(itemTo.getTypeId() != typeid || itemTo.getDurability() != itemFrom.getDurability()) continue;
 +                if(itemTo.getAmount() >= 64) continue;
 +
 +                int maxamount = settings.getInt(typeid, data);
 +                if(maxamount <= 0) continue main;
 +                
 +                int stackspace = 64 - itemTo.getAmount();
 +                int moveamount = (itemFrom.getAmount() >= stackspace && maxamount >= stackspace ? stackspace :
 +                                    itemFrom.getAmount() < stackspace && maxamount >= stackspace ? itemFrom.getAmount() :
 +                                        maxamount < stackspace && itemFrom.getAmount() >= stackspace ? maxamount :
 +                                            maxamount > itemFrom.getAmount() ? itemFrom.getAmount() : maxamount);
 +                //System.out.println("[1]f: (" + itemFrom.getTypeId() + ")" + itemFrom.getAmount() + " t: (" + itemTo.getTypeId() + ")" + itemTo.getAmount() + " d:" + data + " m:" + maxamount + " mv:" + moveamount);
 +                itemFrom.setAmount(itemFrom.getAmount() - moveamount);
 +                itemTo.setAmount(itemTo.getAmount() + moveamount);
 +                if(maxamount != Integer.MAX_VALUE) {
 +                    settings.setInt(typeid, data, maxamount-moveamount);
 +                }
 +                //System.out.println("[1]f: (" + itemFrom.getTypeId() + ")" + itemFrom.getAmount() + " t: (" + itemTo.getTypeId() + ")" + itemTo.getAmount() + " d:" + data + " m:" + settings.getInt(itemFrom.getTypeId(), data) + " mv:" + moveamount);
++=======
+ 
+     public static boolean moveItems(Inventory iFrom, Inventory iTo, IntMap through, boolean toChest) {
+         int slots = 0;
+         ItemStack[] from = iFrom.getContents();
+         ItemStack[] to = iTo.getContents();
+         int i1, i2;
+         for (i1 = 0; i1 < from.length; i1++) {
+             if (from[i1] == null) {
+                 if (!toChest)
+                     slots++;
+                 continue;
++>>>>>>> dev
              }
 -            int mapAmount = through.getInt(from[i1].getType(), (byte) from[i1].getDurability());
 -            int startAmount = from[i1].getAmount();
 -            if (mapAmount == 0 || mapAmount == Integer.MIN_VALUE) {
 +            
 +            if(itemFrom.getAmount() <= 0) {
 +                from[index] = null;
 +                itemFrom.setAmount(0);
                  continue;
              }
++<<<<<<< HEAD
 +            /*
 +             * Put item in an empty slot
 +             */
 +            for(int indexto = 0; indexto < to.length; indexto++ ) {             
 +                if(to[indexto] != null) continue;
 +                int maxamount = settings.getInt(typeid, data);
 +                if(maxamount <= 0) break; //FIX, PROFIT
 +                if(itemFrom.getAmount() > maxamount) {
 +                	//System.out.println("[2]f: (" + itemFrom.getTypeId() + ")" + itemFrom.getAmount() + " m:" + maxamount + " d:" + data);
 +                    itemFrom.setAmount(itemFrom.getAmount() - maxamount);
 +                    to[indexto] = new ItemStack(typeid, maxamount, data);
 +                    settings.setInt(typeid, data, 0);
 +                    //System.out.println("[2]f: (" + itemFrom.getTypeId() + ")" + itemFrom.getAmount() + " m:" + settings.getInt(itemFrom.getTypeId(), data) + " d:" + data);
 +                    break; // We can't put more of this item type so we skip to the next item.
 +                } else {
 +                	//System.out.println("[3]f: (" + itemFrom.getTypeId() + ")" + itemFrom.getAmount() + " m:" + maxamount + " d:" + data);
 +                    to[indexto] = itemFrom;
 +                    from[index] = null;
 +                    if(maxamount != Integer.MAX_VALUE){
 +                        maxamount -= itemFrom.getAmount();
 +                        settings.setInt(typeid, data, maxamount);
++=======
+ 
+             int amountToMove = (mapAmount == Integer.MAX_VALUE ? startAmount : mapAmount);
+             from[i1].setAmount(from[i1].getAmount() - amountToMove + 1);
+             for (i2 = 0; i2 < to.length; i2++) {
+                 if (to[i2] == null) {
+                     to[i2] = from[i1].clone();
+                     to[i2].setAmount(amountToMove);
+                     amountToMove = 0;
+                     if (!toChest || to[i2].getAmount() == 64)
+                         slots++;
+                     break;
+                 } else if (to[i2].getTypeId() == from[i1].getTypeId() && to[i2].getDurability() == from[i1].getDurability() && to[i2].getAmount() < 64) {
+                     if (amountToMove + to[i2].getAmount() > 64) {
+                         amountToMove += to[i2].getAmount() - 64;
+                         to[i2].setAmount(64);
+                         if (toChest)
+                             slots++;
+                     } else {
+                         to[i2].setAmount(amountToMove + to[i2].getAmount());
+                         amountToMove = 0;
++>>>>>>> dev
                      }
 +                    //System.out.println("[3]f: (" + itemFrom.getTypeId() + ")" + itemFrom.getAmount() + " m:" + settings.getInt(itemFrom.getTypeId(), data) + " d:" + data);
                      break;
                  }
              }
++<<<<<<< HEAD
++=======
+             from[i1].setAmount(from[i1].getAmount() + amountToMove - 1);
+             if (!toChest && from[i1] == null || from[i1].getAmount() == 0 || from[i1].getTypeId() == Material.AIR.getId())
+                 slots++;
+             through.setInt(from[i1].getType(), (byte) from[i1].getDurability(), amountToMove);
++>>>>>>> dev
          }
 -        iTo.setContents(to);
          iFrom.setContents(from);
++<<<<<<< HEAD
 +        iTo.setContents(to);
 +        return settings;
++=======
+         return (toChest ? slots == to.length : slots == from.length);
++>>>>>>> dev
      }
 +//    public static void moveItems(Inventory iFrom, Inventory iTo, IntMap through) {
 +//        ItemStack[] from = iFrom.getContents();
 +//        ItemStack[] to = iTo.getContents();
 +//        int i1, i2;
 +//        for (i1 = 0; i1 < from.length; i1++) {
 +//            if (from[i1] == null) {
 +//                //Dat betekent dus dat er geen item in dat slot zit :)
 +//                continue;
 +//            }
 +//            int mapAmount = through.getInt(from[i1].getType(), (byte) from[i1].getDurability());
 +//            mapAmount =  (mapAmount > 64 && mapAmount < Integer.MAX_VALUE)? 64 : mapAmount; //64 stacksizes :)
 +//            int startAmount = from[i1].getAmount(); //De hoeveelheid die in de cart of chest zit
 +//            if (mapAmount == 0 || mapAmount == Integer.MIN_VALUE) {
 +//                continue;
 +//            }
 +//
 +//            int amountToMove = (mapAmount == Integer.MAX_VALUE ? startAmount : mapAmount); //de hoeveelheid die te moven is
 +//            from[i1].setAmount(from[i1].getAmount() - amountToMove + 1);
 +//            boolean hasPutSomethingIn = true;
 +//            for (i2 = 0; i2 < to.length; i2++) {
 +//                if (to[i2] == null) {
 +//                    to[i2] = from[i1].clone();
 +//                    to[i2].setAmount(amountToMove);
 +//                    amountToMove = 0;
 +//                    break;
 +//                } else if (to[i2].getTypeId() == from[i1].getTypeId() && to[i2].getDurability() == from[i1].getDurability() && to[i2].getAmount() < 64) {
 +//                    if (amountToMove + to[i2].getAmount() > 64) {
 +//                        //hier gaat iets mis
 +//                        
 +//                        amountToMove += to[i2].getAmount() - 64;
 +//                        to[i2].setAmount(64);
 +//                        
 +//                    } else {
 +//                        to[i2].setAmount(amountToMove + to[i2].getAmount());
 +//                        amountToMove = 0;
 +//                        
 +//                    }
 +//                    break;
 +//                }
 +//                
 +//                if(i2 == to.length -1){
 +//                    //OEEH, we konden dus niets terug plaatsen
 +//                    hasPutSomethingIn = false;
 +//                    Bukkit.getServer().broadcastMessage("vol is vol");
 +//                }
 +//                
 +//                
 +//            }
 +//            int amountToPlaceBack = from[i1].getAmount() + amountToMove - 1;
 +//            Bukkit.getServer().broadcastMessage(ChatColor.AQUA + "" + amountToPlaceBack);
 +//            from[i1].setAmount(amountToPlaceBack);
 +//            //through.setInt(from[i1].getType(), (byte) from[i1].getDurability(), amountToMove);
 +//            //de bovenstaande regel slaat werkelijk waar nergens over
 +//            
 +//            if((amountToPlaceBack) > 0 && hasPutSomethingIn){
 +//                i1--;
 +//            }
 +//        }
 +//        iTo.setContents(to);
 +//        iFrom.setContents(from);
 +//    }
  
      public static List<Chest> getChestsAroundBlock(Block block, int sw) {
          int nsw = -sw;
